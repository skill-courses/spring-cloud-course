# Spring Boot Schedule

![spring-boot-schedule](../../images/spring-boot/Spring-boot-schedule.png)

在实际开发中，总会有那么一种需求，需要定时去执行的，我们称之为定时任务，例如每小时一次的数据库备份，每天统计前一天的数据并生成报表，每个月月初的工资单的推送，每年一次的生日提醒等等。

虽然，在JDK中，有两个内置类可以实现定时功能：`Timer`和`ScheduledExecutorService`, 但是，在实际开发中，我们其实很少使用这两个类做定时任务，主要有两个方面的原因：
* 它们仅支持按照指定频率，不直接支持指定时间的定时调度，需要我们结合 Calendar 自行计算，才能实现复杂时间的调度。例如说，每天、每周五、2019-11-11 等等。
* 这些定时器都是基于进程级别的，当项目中需要多个进程，存在多个定时器的时候，很难进行统一的任务管理。

基于此，所以，用到的时候大多数需要选择专业的任务调度中间件。

## Spring Task

目前Spring Boot为我们提供了基本的定时任务执行模块：`Spring Task`,属于是Spring Framework的模块，所以在我们引入`spring-boot-starter-web`依赖后，无需特别引入它。

* 在类上，添加`@EnableScheduling`注解，启动Spring Task的定时任务调度的功能。
```java
@Configuration
@EnableScheduling
public class ScheduleConfiguration {
}
```

* 使用`@Scheduled`创建定时任务
```java
@Service
public class ScheduleJob {
    @Scheduled(fixedRate = 2000)
    public void execute() {
        System.out.println("定时任务执行了！");
    }
}
```

这样，我们就创建了每隔两秒执行一次`execute()`方法的定时任务啦。

在上面的入门例子中，使用了`@Scheduled(fixedRate = 2000)`注解来定义每过2秒执行的任务，对于`@Scheduled`的使用的属性有以下几种：
* `fixedRate`：定时任务开始后再次执行定时任务的延时（不需要等待上次定时任务完成），单位毫秒。
* `fixedDelay`：定时任务执行完成后再次执行定时任务的延时（需等待上次定时任务完成），单位毫秒。
* `initialDelay`：第一次执行定时任务的延迟时间，需配合fixedDelay或者fixedRate来使用。
* `cron`: Cron表达式语法，详情参考下面的讲解。

## Cron表达式

## 相关配置

