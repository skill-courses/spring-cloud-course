# Spring Boot 自动装配

![spring-boot-starter](https://tva1.sinaimg.cn/large/e6c9d24egy1h2e4aa71jjj20gr0dp3yw.jpg)

使用过Spring的小伙伴，一定有被XML配置统治的恐惧。即使Spring后面引入了基于注解的配置，我们在开启某些Spring特性或者引入第三方依赖的时候，还是需要用XML或Java进行显式配置。

通过第一节课程的学习，我们知道，Spring Boot项目，我们只需要添加相关依赖，无需配置，通过启动下面的`main`方法即可。
```java
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

不仅仅如此，我们还可以通过Spring Boot的全局配置文件`application.properties`或`application.yml`即可对项目进行设置比如更换端口号，配置数据库连接参数等等。

那为啥Spring Boot使用起来这么顺畅呢？这就得益于Spring Boot的自动装配机制啦！

## 自动配置概述

Spring Boot的自动配置简单的可以理解为：**通过注解或者一些简单的配置就能在Spring Boot的帮助下实现某块功能。**

实际上 Spring Framework早就实现了这个功能。Spring Boot只是在其基础上，通过SPI的方式，做了进一步优化。

其实，Java中自带了所谓SPI机制，按照约定去`META-INF/services`目录里找各个接口的配置文件，找到接口的实现类，然后使用当前线程上线文类加载器定位到实现类加载器，通过其加载实现类，然后再反射`newInstance`得到实现类的实例。

Spring里也有类似的SPI，思路根上面类似，从`classpath`下所有`jar`包的`META-INF/spring.factories`配置文件中加载标识为`EnableAutoConfiguration`的配置类，然后将其中定义的Bean注入到Spring容器。

> SpringBoot定义了一套接口规范，这套规范规定：SpringBoot在启动时会扫描外部引用jar包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到Spring容器，并执行类中定义的各种操作。对于外部jar来说，只需要按照SpringBoot定义> 的标准，就能将自己的功能装置进SpringBoot。

所以，Spring Boot的自动装配是通过注解`@SpringBootApplication`来实现的，通过前面的课程学习，我们知道此注解相当于三个注解的组合`@EnableAutoConfiguration`/`@Configuration`/`@ComponentScan`。 

其中`@EnableAutoConfiguration`注解表示启用SpringBoot的自动配置机制，此注解是实现自动装配的核心。

## Bean的自动配置

那么我们来研究一下`@EnableAutoConfiguration`注解的源码实现：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage //作用：将main包下的所欲组件注册到容器中
@Import({AutoConfigurationImportSelector.class}) //加载自动装配类 xxxAutoconfiguration
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
```

从上面的`EnableAutoConfiguration`类可以看出，主要起关键作用的类是：`AutoConfigurationImportSelector`, 我们来扒一扒这类的作用：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {}

public interface DeferredImportSelector extends ImportSelector {}

public interface ImportSelector {
    String[] selectImports(AnnotationMetadata var1);
}
```

可以看出，`AutoConfigurationImportSelector`类实现了`ImportSelector`接口，也就实现了这个接口中的 `selectImports`方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。

```java
private static final String[] NO_IMPORTS = new String[0];

public String[] selectImports(AnnotationMetadata annotationMetadata) {
        // <1>.判断自动装配开关是否打开
        if (!this.isEnabled(annotationMetadata)) {
            return NO_IMPORTS;
        } else {
          //<2>.获取所有需要装配的bean
            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);
            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
        }
    }
```

这里我们需要重点关注一下getAutoConfigurationEntry()方法，这个方法主要负责加载自动配置类的。我们简单来阐述以下这个方法的执行过程：
1. 判断自动装配开关是否打开。默认`spring.boot.enableautoconfiguration=true`，可在`application.properties`或`application.yml`中设置.
2. 用于获取EnableAutoConfiguration注解中的`exclude`和`excludeName`。
3. 获取需要自动装配的所有配置类，读取`META-INF/spring.factories`。
4. 按条件加载`META-INF/spring.factories`里面的配置。

### 条件注解

上面按条件加载`META-INF/spring.factories`里面的配置，使用的就是条件注解。条件注解并不是 Spring Boot 所独有，而是在Spring3.1版本时，为了满足不同环境注册不同的Bean ，引入了`@Profile`注解。

例如，可以针对不同环境，读取不同环境的数据库配置：
```java
@Configuration
public class DataSourceConfiguration {

    @Bean
    @Profile("DEV")
    public DataSource devDataSource() {
        // 本地环境的数据库配置
    }

    @Bean
    @Profile("PROD")
    public DataSource prodDataSource() {
        // 生产环境的数据库配置
    }
}
```

在 Spring4 版本时，提供了 @Conditional 注解，用于声明在配置类或者创建 Bean 的方法上，表示需要满足指定条件才能生效。示例代码如下：

```java
@Configuration
public class TestConfiguration {

    @Bean
    @Conditional(XXXCondition.class)
    public Object xxxObject() {
        return new Object();
    }   
}
```

其中，`XXXCondition`需要我们自己实现`Condition`接口，提供具体的条件实现。

显然，Spring4 提交的 @Conditional 注解非常不方便，需要我们自己去拓展。因此，Spring Boot进一步增强，提供了常用的条件注解：
* @ConditionalOnBean：当容器里有指定 Bean 的条件下
* @ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下
* @ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean
* @ConditionalOnClass：当类路径下有指定类的条件下
* @ConditionalOnMissingClass：当类路径下没有指定类的条件下
* @ConditionalOnProperty：指定的属性是否有指定的值
* @ConditionalOnResource：类路径是否有指定的值
* @ConditionalOnExpression：基于 SpEL 表达式作为判断条件
* @ConditionalOnJava：基于 Java 版本作为判断条件
* @ConditionalOnJndi：在 JNDI 存在的条件下差在指定的位置
* @ConditionalOnNotWebApplication：当前项目不是 Web 项目的条件下
* @ConditionalOnWebApplication：当前项目是 Web项 目的条件下

## 属性注解

在使用 Spring Boot时，我们仅需在`build.gradle`文件中，引入需要组件的`*-starter`依赖，并在 `application.yaml`等配置文件中添加该组件定义的配置项，最终Spring Boot在自动化配置时，会基于该组件的配置项 + 配置类，自动创建该组件的Bean们。

例如说，我们想要初始化数据库连接池组件，所以我们引入`spring-boot-starter-jdbc`依赖，并在 `application.yaml`配置文件中添加该组件的`spring.datasource`配置项。

Spring Boot支持`Properties`、`YAML`、`JSON`三种格式的配置文件。目前主流的采用的是`Properties`或是`YAML`格式. 本文的示例，我们会以`application.yaml`配置文件为主哈。

使用属性注解，我们需要先来了解`@value`的用法:

***@Value 就相当于传统 xml 配置文件中的 value 字段。***

我们知道配置文件中的 value 的取值可以是：
* 字面量
* 通过 ${key} 方式从环境变量中获取值
* 通过 ${key} 方式全局配置文件中获取值 
* #{SpEL}

所以，我们就可以通过`@Value(${key})`的方式获取全局配置文件中的指定配置项.

如果我们需要取N个配置项，通过`@Value`的方式去配置项需要一个一个去取，这就显得有点low了。我们可以使用 注解`@ConfigurationProperties`来实现。

标有 @ConfigurationProperties 的类的所有属性和配置文件中相关的配置项进行绑定。（默认从全局配置文件中获取配置值），绑定之后我们就可以通过这个类去访问全局配置文件中的属性值了。

例如：
在`application.yaml`中添加如下的配置：
```yml
student.name=zhangsan
student.age=18
student.sex=male
```

创建配置类，使用此注解进行标注：
```java
@Component 
@ConfigurationProperties(prefix = "student")
@Getter
@Setter
public class Student { 
    private String name; 
    private Integer age; 
    private String sex; 
}
```

这里`@ConfigurationProperties`有一个`prefix`参数，主要是用来指定该配置项在配置文件中的前缀。

当Spring容器启动的时候，Student类会被注入到IOC容器中。

## 关于Spring Boot Starter