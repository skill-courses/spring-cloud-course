# Spring Boot 自动装配

![spring-boot-starter](https://tva1.sinaimg.cn/large/e6c9d24egy1h2e4aa71jjj20gr0dp3yw.jpg)

使用过Spring的小伙伴，一定有被XML配置统治的恐惧。即使Spring后面引入了基于注解的配置，我们在开启某些Spring特性或者引入第三方依赖的时候，还是需要用XML或Java进行显式配置。

通过第一节课程的学习，我们知道，Spring Boot项目，我们只需要添加相关依赖，无需配置，通过启动下面的`main`方法即可。
```java
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

不仅仅如此，我们还可以通过Spring Boot的全局配置文件`application.properties`或`application.yml`即可对项目进行设置比如更换端口号，配置数据库连接参数等等。

那为啥Spring Boot使用起来这么顺畅呢？这就得益于Spring Boot的自动装配机制啦！

## 自动配置概述

Spring Boot的自动配置简单的可以理解为：**通过注解或者一些简单的配置就能在Spring Boot的帮助下实现某块功能。**

实际上 Spring Framework早就实现了这个功能。Spring Boot只是在其基础上，通过SPI的方式，做了进一步优化。

其实，Java中自带了所谓SPI机制，按照约定去`META-INF/services`目录里找各个接口的配置文件，找到接口的实现类，然后使用当前线程上线文类加载器定位到实现类加载器，通过其加载实现类，然后再反射`newInstance`得到实现类的实例。

Spring里也有类似的SPI，思路根上面类似，从`classpath`下所有`jar`包的`META-INF/spring.factories`配置文件中加载标识为`EnableAutoConfiguration`的配置类，然后将其中定义的Bean注入到Spring容器。

> SpringBoot定义了一套接口规范，这套规范规定：SpringBoot在启动时会扫描外部引用jar包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到Spring容器，并执行类中定义的各种操作。对于外部jar来说，只需要按照SpringBoot定义> 的标准，就能将自己的功能装置进SpringBoot。

所以，Spring Boot的自动装配是通过注解`@SpringBootApplication`来实现的，通过前面的课程学习，我们知道此注解相当于三个注解的组合`@EnableAutoConfiguration`/`@Configuration`/`@ComponentScan`。 

其中`@EnableAutoConfiguration`注解表示启用SpringBoot的自动配置机制，此注解是实现自动装配的核心。

## Bean的自动配置

那么我们来研究一下`@EnableAutoConfiguration`注解的源码实现：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage //作用：将main包下的所欲组件注册到容器中
@Import({AutoConfigurationImportSelector.class}) //加载自动装配类 xxxAutoconfiguration
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
```

## 属性的自动配置

## 条件注解

## 关于Spring Boot Starter