# Spring 事务规则

![spring-transaction-Propagation](../../../images/spring-data/Spring-Transaction-Propagation.jpeg)

实际的业务开发中，使用最多的就是`@Transactional`注解了，这个注解里面参数多多，了解这个注解里面的参数有助于我们平时刚好的实现开发需求。

## @Transactional注解

此注解可以使用在类，方法和接口上面，推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。通常情况下，不推荐在接口上使用。

@Transactional注解源码如下：
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
	@AliasFor("transactionManager")
	String value() default "";
	@AliasFor("value")
	String transactionManager() default "";
    // 事务的传播行为，默认值为 REQUIRED
	Propagation propagation() default Propagation.REQUIRED;
    // 事务的隔离级别，默认值采用 DEFAULT
	Isolation isolation() default Isolation.DEFAULT;
    // 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。
	int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;
    //指定事务是否为只读事务，默认值为 false。
	boolean readOnly() default false;
    // 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。
	Class<? extends Throwable>[] rollbackFor() default {};

	String[] rollbackForClassName() default {};

	Class<? extends Throwable>[] noRollbackFor() default {};

	String[] noRollbackForClassName() default {};
}
```

该注解的实现原理是：如果一个类或者一个类中的`public`方法上被标注`@Transactional`注解的话，Spring容器就会在启动的时候为其创建一个代理类，在调用被`@Transactional`注解的 `public`方法的时候，实际调用的是，`TransactionInterceptor`类中的`invoke()`方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。

下面，我们就来详细了解这个注解里面的属性吧！

## 隔离级别

数据库的事务隔离性有四种，这四种在Spring中全部被支持并扩展，Spring 中默认的事务隔离级别是 default，即数据库本身的隔离级别是啥就是啥，default 就能满足我们日常开发中的大部分场景。

`TransactionDefinition`接口中定义了五个表示隔离级别的常量：
```java
public interface TransactionDefinition {
    ......
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    ......
}
```
为了方便使用，Spring 也相应地定义了一个枚举类：Isolation:
```java
public enum Isolation {
  // 使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别
  DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),
  // 最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
  READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),
  // 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
  READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),
  // 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
  REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),
  // 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。
  SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);

  private final int value;

  Isolation(int value) {
    this.value = value;
  }

  public int value() {
    return this.value;
  }
}
```

## 传播机制

## 回滚与异常处理

## 失效场景